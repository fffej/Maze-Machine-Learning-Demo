<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Drawing;
<#
string[] names = {"Coordinate", "Vector"};
string[] types = {"int", "double"};
string[] casts = {"", "(int)", "(double)", "(float)"};
string[] all = new string[types.Length + names.Length];
string[] ops = {"+", "-", "*", "/"};

Array.Copy(names, all, names.Length);
Array.Copy(types, 0, all, names.Length, types.Length);
#>

namespace Maze_Machine_Learning.ABUtil
{
	class Angle
	{
		private double _theta;
		public double Magnitude { get; set; }

		public double Theta
		{
			get { return _theta; }
			set { _theta = value % Constants.Circles.Tau; }
		}
		
        public double X
        {
            get { return Magnitude * Math.Cos(_theta); }
            set { Theta = Math.Atan(Y / value); Magnitude = Math.Sqrt(value * value + Y * Y); }
        }

        public double Y
        {
            get { return Magnitude * Math.Sin(_theta); }
            set { Theta = Math.Atan(value / X); Magnitude = Math.Sqrt(X * X + value * value); }
        }

		public Vector Vector
		{
			get { return new Vector(X, Y); }
			set { X = value.X; Y = value.Y; }
		}

		public Angle()
			:this(0, 0)
		{}

		public Angle(double theta, double magnitude)
		{
			Theta = theta;
			Magnitude = magnitude;
		}
	}

<# for (int i = 0; i < names.Length; ++i) { #>
<# int int_cast = types[i] == "int" ? 1 : 0; #>
<# int dub_cast = types[i] == "double" ? 2 : 0; #>
<# int flt_cast = types[i] == "double" ? 3 : 0; #>
	class <#= names[i] #>
	{
		public <#= types[i] #> X { get; set; }
		public <#= types[i] #> Y { get; set; }

		public double Magnitude
		{
			get { return Math.Sqrt(X * X + Y * Y); }
			set {
				
			}
		}
		
		public <#= names[1 - i] #> <#= names[1 - i] #>
		{
			get { return new <#= names[1 - i] #>(X, Y); }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}
<# if (names[i] == "Vector") { #>

		public Angle Angle
		{
			get { return new Angle {Vector = this}; }
			set { X = value.X; Y = value.Y; }
		}
<# } #>

		public PointF PointF
		{
			get { return new PointF(<#= casts[flt_cast] #>X, <#= casts[flt_cast] #>Y); }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public <#= types[i] #>[] Array
		{
			get { return new[] {X, Y}; }
			set
			{
				try
				{
					X = value[0];
					Y = value[1];
				}
                catch (IndexOutOfRangeException)
                {
                    throw new ArgumentException(Constants.Strings.ArrayToSmall2);
                }
			}
		}

        public <#= types[i] #> this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0:
                        return X;
                    case 1:
                        return Y;
                    default:
                        throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0:
                        X = value;
                        break;
                    case 1:
                        Y = value;
                        break;
                    default:
                        throw new IndexOutOfRangeException();
                }
            }
        }
	
		public <#= names[i] #>()
			: this(0, 0)
		{}
	
<# for (int c = 0; c < types.Length; ++c) { #>
		public <#= names[i] #>(<#= types[c] #> x, <#= types[c] #> y)
		{
			X = <# if (types[c] == "double" && types[i] == "int") { #>(<#= types[i] #>)<# } #>x;
			Y = <# if (types[c] == "double" && types[i] == "int") { #>(<#= types[i] #>)<# } #>y;
		}

<# } #>
<# for (int c = 0; c < names.Length; ++c) { #>
		public <#= names[i] #>(<#= names[c] #> other)
		{
			X = <# if (types[c] == "double") { #><#= casts[int_cast] #><# } #>other.X;
			Y = <# if (types[c] == "double") { #><#= casts[int_cast] #><# } #>other.Y;
		}

<# } #>
<#	for (int o = 0; o < ops.Length; ++o) { #>
<#		for (int a = 0; a < all.Length; ++a) { #>
<#			if (!(names[i] == "Coordinate" && all[a] == "Vector")) { #>
<# string acc_X = a < 2 ? ".X" : ""; #>
<# string acc_Y = a < 2 ? ".Y" : ""; #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= names[i] #> a, <#= all[a] #> b) { return new <#= names[i] #>(a.X <#= ops[o] #> b<#= acc_X #>, a.Y <#= ops[o] #> b<#= acc_X #>); }
<#				if (all[a] != names[i]) { #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= all[a] #> a, <#= names[i] #> b) { return new <#= names[i] #>(a<#= acc_X #> <#= ops[o] #> b.X, a<#= acc_X #> <#= ops[o] #> b.Y); }
<#				} #>
<#			} #>
<#		} #>

<# } #>
		public static Vector operator +(<#= names[i] #> v, Angle a) { return new Vector(v.X + a.X, v.Y + a.Y); }

		public int Length()
		{
			return 2;
		}
	}

<# } #>
}