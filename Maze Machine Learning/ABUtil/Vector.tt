<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Drawing;
<#
string[] names = {"Coordinate", "Vector"};
string[] types = {"int", "double"};
string[] casts = {"", "(int)", "(double)", "(float)"};
string[] all = new string[types.Length + names.Length];
string[] ops = {"+", "-", "*", "/"};

Array.Copy(names, all, names.Length);
Array.Copy(types, 0, all, names.Length, types.Length);
#>

namespace Maze_Machine_Learning.ABUtil
{
<# for (int i = 0; i < names.Length; ++i) { #>
<# int int_cast = types[i] == "int" ? 1 : 0; #>
<# int inv_int_cast = types[i] == "double" ? 1 : 0; #>
<# int dub_cast = types[i] == "double" ? 2 : 0; #>
<# int flt_cast = types[i] == "double" ? 3 : 0; #>
<# string Vec = names[i] == "Vector" ? "this" : "Vec"; #>
	struct <#= names[i] #>
	{
		public const int Length = 2;
		public <#= types[i] #> X { get; set; }
		public <#= types[i] #> Y { get; set; }
		
		public <#= names[1 - i] #> <#= i == 0 ? names[1 - i].Substring(0, 3) : names[1 - i].Substring(0, 5) #>
		{
			get { return new <#= names[1 - i] #> {X = <#= casts[inv_int_cast] #>X, Y = <#= casts[inv_int_cast] #>Y}; }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public double Magnitude
		{
			get { return Math.Sqrt(X * X + Y * Y); }
			set { Angle = new Angle {Vec = <#= Vec #>, Magnitude = value - Magnitude}; }
		}

		public Angle Angle
		{
			get { return new Angle {Vec = <#= Vec #>}; }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public PointF PointF
		{
			get { return new PointF(<#= casts[flt_cast] #>X, <#= casts[flt_cast] #>Y); }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public <#= types[i] #>[] Array
		{
			get { return new[] {X, Y}; }
			set { X = value[0]; Y = value[1]; }
		}

		public <#= types[i] #> this[int index]
		{
			get
			{
				switch (index)
				{
					case 0:
						return X;
					case 1:
						return Y;
					default:
						throw new IndexOutOfRangeException();
				}
			}
			set
			{
				switch (index)
				{
					case 0:
						X = value;
						break;
					case 1:
						Y = value;
						break;
					default:
						throw new IndexOutOfRangeException();
				}
			}
		}

<#	for (int o = 0; o < ops.Length; ++o) { #>
<#		for (int a = 0; a < all.Length; ++a) { #>
<#			if (!(names[i] == "Coordinate" && all[a] == "Vector")) { #>
<#				string acc_X = "";
				string acc_Y = "";
				string cast_arg = all[a] == "double" ? casts[int_cast] : "";

				if (a < 2) {
					acc_X = ".X";
					acc_Y = ".Y";
					cast_arg = "";
				} #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= names[i] #> a, <#= all[a] #> b) { return new <#= names[i] #> {X = a.X <#= ops[o] #> <#= cast_arg #>b<#= acc_X #>, Y = a.Y <#= ops[o] #> <#= cast_arg #>b<#= acc_Y #>}; }
<#				if (all[a] != names[i]) { #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= all[a] #> a, <#= names[i] #> b) { return new <#= names[i] #> {X = <#= cast_arg #>a<#= acc_X #> <#= ops[o] #> b.X, Y = <#= cast_arg #>a<#= acc_Y #> <#= ops[o] #> b.Y}; }
<#				} #>
<#			} #>
<#		} #>

<# } #>
		public static Vector operator +(<#= names[i] #> v, Angle a) { return new Vector {X = v.X + a.X, Y = v.Y + a.Y}; }
	}

<# } #>
}