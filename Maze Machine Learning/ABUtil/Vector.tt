<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Collections;
using System.Drawing;
<#
string[] names = {"Coordinate", "Vector"};
string[] types = {"int", "double"};
string[] casts = {"", "(int)", "(double)", "(float)"};
string[] all = new string[types.Length + names.Length];
string[] ops = {"+", "-", "*", "/"};

Array.Copy(names, all, names.Length);
Array.Copy(types, 0, all, names.Length, types.Length);
#>

namespace Maze_Machine_Learning.ABUtil
{
	public class VecEnumerable<T> : IEnumerable
	{
		public const int Length = 2;
		public T X { get; set; }
		public T Y { get; set; }

		public IEnumerator GetEnumerator()
		{
			yield return X;
			yield return Y;
		}

		public T[] Array
		{
			get { return new[] { X, Y }; }
			set { X = value[0]; Y = value[1]; }
		}

		public T this[int index]
		{
			get
			{
				switch (index)
				{
					case 0:
						return X;
					case 1:
						return Y;
					default:
						throw new IndexOutOfRangeException();
				}
			}
			set
			{
				switch (index)
				{
					case 0:
						X = value;
						break;
					case 1:
						Y = value;
						break;
					default:
						throw new IndexOutOfRangeException();
				}
			}
		}
	}
<# for (int i = 0; i < names.Length; ++i) { #>
<# int int_cast = types[i] == "int" ? 1 : 0; #>
<# int dub_cast = types[i] == "double" ? 2 : 0; #>
<# int inv_int_cast = types[i] == "double" ? 1 : 0; #>
<# int flt_cast = types[i] == "double" ? 3 : 0; #>
<# string Vec = names[i] == "Vector" ? "this" : "Vec"; #>

	public class <#= names[i] #> : VecEnumerable<<#= types[i] #>>
	{
		public <#= names[1 - i] #> <#= i == 0 ? names[1 - i].Substring(0, 3) : names[1 - i].Substring(0, 5) #>
		{
			get { return new <#= names[1 - i] #> {X = <#= casts[inv_int_cast] #>X, Y = <#= casts[inv_int_cast] #>Y}; }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public double Magnitude
		{
			get { return Math.Sqrt(X * X + Y * Y); }
			set { Angle = new Angle {Vec = <#= Vec #>, Magnitude = value - Magnitude}; }
		}

		public Angle Angle
		{
			get { return new Angle {Vec = <#= Vec #>}; }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public PointF PointF
		{
			get { return new PointF(<#= casts[flt_cast] #>X, <#= casts[flt_cast] #>Y); }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

        public <#= names[i] #>()
            : this(0, 0)
        {}

        public <#= names[i] #>(<#= types[i] #> x, <#= types[i] #> y)
        {
            X = x;
            Y = y;
        }

		public void Abs()
		{
			X = Math.Abs(X);
			Y = Math.Abs(Y);
		}

<#	for (int o = 0; o < ops.Length; ++o) { #>
<#		for (int a = 0; a < all.Length; ++a) { #>
<#			if (!(names[i] == "Coordinate" && all[a] == "Vector")) { #>
<#				string acc_X = "";
				string acc_Y = "";
				string cast_arg = all[a] == "double" ? casts[int_cast] : "";

				if (a < 2) {
					acc_X = ".X";
					acc_Y = ".Y";
					cast_arg = "";
				} #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= names[i] #> a, <#= all[a] #> b) { return new <#= names[i] #>(a.X <#= ops[o] #> <#= cast_arg #>b<#= acc_X #>, a.Y <#= ops[o] #> <#= cast_arg #>b<#= acc_Y #>); }
<#				if (all[a] != names[i]) { #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= all[a] #> a, <#= names[i] #> b) { return new <#= names[i] #>(<#= cast_arg #>a<#= acc_X #> <#= ops[o] #> b.X, <#= cast_arg #>a<#= acc_Y #> <#= ops[o] #> b.Y); }
<#				} #>
<#			} #>
<#		} #>

<# } #>
		public static Vector operator +(<#= names[i] #> v, Angle a) { return new Vector(v.X + a.X, v.Y + a.Y); }
		
		public static bool operator ==(<#= names[i] #> t, Vector v) { return t.Equals(v); }
		public static bool operator ==(<#= names[i] #> t, Coordinate c) { return t.Equals(c); }
		public static bool operator ==(<#= names[i] #> t, Angle a) { return t.Equals(a); }
		public static bool operator !=(<#= names[i] #> t, Vector v) { return !t.Equals(v); }
		public static bool operator !=(<#= names[i] #> t, Coordinate c) { return !t.Equals(c); }
		public static bool operator !=(<#= names[i] #> t, Angle a) { return !t.Equals(a); }

		public bool Equals(Coordinate obj) { return <#= casts[inv_int_cast] #>X == obj.X && <#= casts[inv_int_cast] #>Y == obj.Y; }
<#  string compare = "return X == " + casts[int_cast] + "obj.X && Y == " + casts[int_cast] + "obj.Y;"; #>
<#  if (names[i] == "Vector") compare = "return ExtraMath.Compare(X, obj.X) && ExtraMath.Compare(Y, obj.Y);"; #>
		public bool Equals(Vector obj) { <#= compare #> }
		public bool Equals(Angle obj) { <#= compare #> }
		override public bool Equals(object obj) { return false; }

		override public int GetHashCode() { return <#= casts[inv_int_cast] #>(X + ExtraMath.HashPrime * Y); }
	}

<# } #>
}