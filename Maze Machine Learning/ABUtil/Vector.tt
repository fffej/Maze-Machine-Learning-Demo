<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Drawing;
<#
string[] names = {"Coordinate", "Vector"};
string[] types = {"int", "double"};
string[] casts = {"", "(int)", "(double)", "(float)"};
string[] all = new string[types.Length + names.Length];
string[] ops = {"+", "-", "*", "/"};

Array.Copy(names, all, names.Length);
Array.Copy(types, 0, all, names.Length, types.Length);
#>

namespace Maze_Machine_Learning.ABUtil
{
<# for (int i = 0; i < names.Length; ++i) { #>
<# int int_cast = types[i] == "int" ? 1 : 0; #>
<# int dub_cast = types[i] == "double" ? 2 : 0; #>
<# int flt_cast = types[i] == "double" ? 3 : 0; #>
<# string Vec = names[i] == "Vector" ? "this" : "Vec"; #>
	class <#= names[i] #>
	{
		public <#= types[i] #> X { get; set; }
		public <#= types[i] #> Y { get; set; }
		
		public <#= names[1 - i] #> <#= i == 0 ? names[1 - i].Substring(0, 3) : names[1 - i].Substring(0, 5) #>
		{
			get { return new <#= names[1 - i] #>(X, Y); }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public double Magnitude
		{
			get { return Math.Sqrt(X * X + Y * Y); }
			set { Angle = new Angle {Vec = <#= Vec #>, Magnitude = value - Magnitude}; }
		}

		public Angle Angle
		{
			get { return new Angle {Vec = <#= Vec #>}; }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public PointF PointF
		{
			get { return new PointF(<#= casts[flt_cast] #>X, <#= casts[flt_cast] #>Y); }
			set { X = <#= casts[int_cast] #>value.X; Y = <#= casts[int_cast] #>value.Y; }
		}

		public <#= types[i] #>[] Array
		{
			get { return new[] {X, Y}; }
			set
			{
				try
				{
					X = value[0];
					Y = value[1];
				}
				catch (IndexOutOfRangeException)
				{
					throw new ArgumentException(Constants.Strings.ArrayToSmall2);
				}
			}
		}

		public <#= types[i] #> this[int index]
		{
			get
			{
				switch (index)
				{
					case 0:
						return X;
					case 1:
						return Y;
					default:
						throw new IndexOutOfRangeException();
				}
			}
			set
			{
				switch (index)
				{
					case 0:
						X = value;
						break;
					case 1:
						Y = value;
						break;
					default:
						throw new IndexOutOfRangeException();
				}
			}
		}
	
		public <#= names[i] #>()
			: this(0, 0)
		{}
	
<# for (int c = 0; c < types.Length; ++c) { #>
		public <#= names[i] #>(<#= types[c] #> x, <#= types[c] #> y)
		{
			X = <# if (types[c] == "double" && types[i] == "int") { #>(<#= types[i] #>)<# } #>x;
			Y = <# if (types[c] == "double" && types[i] == "int") { #>(<#= types[i] #>)<# } #>y;
		}

<# } #>
<# for (int c = 0; c < names.Length; ++c) { #>
		public <#= names[i] #>(<#= names[c] #> other)
		{
			X = <# if (types[c] == "double") { #><#= casts[int_cast] #><# } #>other.X;
			Y = <# if (types[c] == "double") { #><#= casts[int_cast] #><# } #>other.Y;
		}

<# } #>
<#	for (int o = 0; o < ops.Length; ++o) { #>
<#		for (int a = 0; a < all.Length; ++a) { #>
<#			if (!(names[i] == "Coordinate" && all[a] == "Vector")) { #>
<# string acc_X = a < 2 ? ".X" : ""; #>
<# string acc_Y = a < 2 ? ".Y" : ""; #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= names[i] #> a, <#= all[a] #> b) { return new <#= names[i] #>(a.X <#= ops[o] #> b<#= acc_X #>, a.Y <#= ops[o] #> b<#= acc_X #>); }
<#				if (all[a] != names[i]) { #>
		public static <#= names[i] #> operator <#= ops[o] #>(<#= all[a] #> a, <#= names[i] #> b) { return new <#= names[i] #>(a<#= acc_X #> <#= ops[o] #> b.X, a<#= acc_X #> <#= ops[o] #> b.Y); }
<#				} #>
<#			} #>
<#		} #>

<# } #>
		public static Vector operator +(<#= names[i] #> v, Angle a) { return new Vector(v.X + a.X, v.Y + a.Y); }

		public int Length()
		{
			return 2;
		}
	}

<# } #>
}